# -*- coding: utf-8 -*-
"""Code Structure updated.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qrMu4aw2fK0L3Y8y7ETAIhI7yXt4KSEK
"""

import os
from pycparser import c_parser, c_ast

class FunctionCollector(c_ast.NodeVisitor):
    """
    Visitor class to collect all function definitions by name.
    """
    def __init__(self):
        self.functions = {}

    def visit_FuncDef(self, node):
        func_name = node.decl.name
        self.functions[func_name] = node
        self.generic_visit(node)

class CodeComparator:
    def __init__(self):
        self.compare_data_structures = False
        self.compare_control_structures = False
        self.compare_modularity = False
        self.compare_functionality = False

    def enable_priority(self, priority):
        """
        Enable comparison for the given priority ('data', 'control', 'modularity', or 'functionality').
        """
        if priority == 'data':
            self.compare_data_structures = True
        elif priority == 'control':
            self.compare_control_structures = True
        elif priority == 'functionality':
            self.compare_functionality = True
        else:
            self.compare_control_structures = True
            self.compare_data_structures = True
            self.compare_modularity = True
            self.compare_functionality = True

    def preprocess_file(self, file_path):
        """
        Preprocess a C source file to handle macros and includes.
        Returns the preprocessed code as a string.
        """
        try:
            import subprocess
            preprocessed_code = subprocess.check_output(
                ["gcc", "-E", file_path], universal_newlines=True
            )
            return preprocessed_code
        except FileNotFoundError:
            print("Error: gcc is not installed or not in PATH.")
            exit()
        except Exception as e:
            print(f"Error during preprocessing: {e}")
            exit()
    def extract_data_structures(self, ast_node):
        """
        Recursively extract data structure declarations (e.g., arrays, structs) from the AST.
        """
        data_structures = []
        if ast_node is None:
            return data_structures

        if isinstance(ast_node, c_ast.Struct):
            data_structures.append(f"struct {ast_node.name}")
        elif isinstance(ast_node, c_ast.ArrayDecl):
            data_structures.append("array")

        if hasattr(ast_node, 'children'):
            for _, child in ast_node.children():
                data_structures.extend(self.extract_data_structures(child))

        return data_structures

    def extract_control_structures(self, ast_node):
        """
        Recursively extract control structure declarations (e.g., for, while, if) from the AST.
        """
        control_structures = []
        if ast_node is None:
            return control_structures

        if isinstance(ast_node, c_ast.For):
            control_structures.append("for loop")
        elif isinstance(ast_node, c_ast.While):
            control_structures.append("while loop")
        elif isinstance(ast_node, c_ast.DoWhile):
            control_structures.append("do-while loop")
        elif isinstance(ast_node, c_ast.If):
            control_structures.append("if statement")
        elif isinstance(ast_node, c_ast.Switch):
            control_structures.append("switch statement")

        if hasattr(ast_node, 'children'):
            for _, child in ast_node.children():
                control_structures.extend(self.extract_control_structures(child))

        return control_structures

    def collect_functions(self, c_code):
        """
        Parse the C code and collect all functions by name.
        """
        parser = c_parser.CParser()
        ast = parser.parse(c_code)
        collector = FunctionCollector()
        collector.visit(ast)
        return collector.functions

    def compare_functions(self, teacher_functions, student_functions):
        """
        Compare functions between teacher and student files based on their structure.
        """
        matched_funcs = {}
        unmatched_teacher_funcs = set(teacher_functions.keys())
        unmatched_student_funcs = set(student_functions.keys())

        for teacher_name, teacher_func in teacher_functions.items():
            for student_name in list(unmatched_student_funcs):
                if self.are_functions_equivalent(teacher_func, student_functions[student_name]):
                    matched_funcs[teacher_name] = student_name
                    unmatched_student_funcs.remove(student_name)
                    unmatched_teacher_funcs.discard(teacher_name)
                    break

        return {
            "matched": matched_funcs,
            "unmatched_teacher": unmatched_teacher_funcs,
            "unmatched_student": unmatched_student_funcs
        }

    def are_functions_equivalent(self, func1, func2):
        """
        Compare two functions' ASTs to check if they are structurally equivalent.
        """
        differences = []
        self.compare_asts(func1.body, func2.body, differences)
        return len(differences) == 0

    def compare_asts(self, node1, node2, differences):
        """
        Compare two ASTs node by node.
        """
        if type(node1) != type(node2):
            differences.append(f"Expected {type(node1).__name__}, but found {type(node2).__name__}.")
            return

        if isinstance(node1, c_ast.Node) and isinstance(node2, c_ast.Node):
            children1 = node1.children()
            children2 = node2.children()

            if len(children1) != len(children2):
                differences.append(
                    f"Mismatch in number of child nodes: expected {len(children1)}, but found {len(children2)}."
                )
                return

            for (attr1, child1), (attr2, child2) in zip(children1, children2):
                if attr1 != attr2:
                    differences.append(f"Mismatch in attributes: expected {attr1}, but found {attr2}.")
                self.compare_asts(child1, child2, differences)

    def compare_files(self, file1, file2):
        """
        Compare data structures, control structures, modularity, and functionality between two C source files.
        """
        parser = c_parser.CParser()

        try:
            code1 = self.preprocess_file(file1)
            code2 = self.preprocess_file(file2)

            ast1 = parser.parse(code1)
            ast2 = parser.parse(code2)

            result = {}

            if self.compare_data_structures:
                data_structures1 = set(self.extract_data_structures(ast1))
                data_structures2 = set(self.extract_data_structures(ast2))

                result['data_structures'] = {
                    "common": data_structures1 & data_structures2,
                    "unique_to_file1": data_structures1 - data_structures2,
                    "unique_to_file2": data_structures2 - data_structures1
                }

            if self.compare_control_structures:
                control_structures1 = set(self.extract_control_structures(ast1))
                control_structures2 = set(self.extract_control_structures(ast2))

                result['control_structures'] = {
                    "common": control_structures1 & control_structures2,
                    "unique_to_file1": control_structures1 - control_structures2,
                    "unique_to_file2": control_structures2 - control_structures1,
                }



            if self.compare_functionality:
                functions_in_file2 = len(self.collect_functions(code2))


                teacher_functions = self.collect_functions(code1)
                student_functions = self.collect_functions(code2)
                extra_functions = [func for func in teacher_functions if func != "main"]
                extra1_functions= [func for func in student_functions if func != "main"]
                result['modularity'] = {
                      "functions_in_student_file": functions_in_file2,
                      "feedback": "Consider breaking down the code into smaller functions." if functions_in_file2 <2 and extra_functions else "Good modularity."
                  }
                function_comparison = self.compare_functions(teacher_functions, student_functions)
                result['functionality'] = function_comparison

            return result

        except Exception as e:
            print(f"Error parsing files: {e}")
            return None

if __name__ == "__main__":
    file1 = "/content/arth.c"
    file2 = "/content/arth1.c"

    comparator = CodeComparator()
    value = input("Prompt message [1:data 2:control 3:functionality 4:all]: ")

    if value == "1":
        comparator.enable_priority('data')
    elif value == "2":
        comparator.enable_priority('control')

    elif value == "3":
        comparator.enable_priority('functionality')
    else:
        comparator.enable_priority('all')

    if not (os.path.exists(file1) and os.path.exists(file2)):
        print("Both source files must exist.")
        exit()

    result = comparator.compare_files(file1, file2)
    if result:
        print("\nComparison Result:")

        if 'data_structures' in result:
            print("Data Structures:")
            if len(result['data_structures']['unique_to_file1'])==0:
              print("No data structures are lacking")
            else:
              print(f"Student file lack {result['data_structures']['unique_to_file1']} data structure ")


        if 'control_structures' in result:
            print("Control Structures:")
            if len(result['control_structures']['unique_to_file1'])==0:
              print("No control structures are lacking")
            else:
              print(f"Student file lack {result['control_structures']['unique_to_file1']} control structure ")


        if 'functionality' in result:
            print("Modularity:")
            print(f"  Feedback: {result['modularity']['feedback']}")
            print("Functionality:")
            print(f"  Matched Functions: {result['functionality']['matched']}")
            if len(result['functionality']['unmatched_student'])==0:
              print(" All functions are matching")
            else:
              print(" All functions are not matching")